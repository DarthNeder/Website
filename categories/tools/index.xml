<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tools on crazyc4t's blog</title><link>https://crazyc4t.xyz/categories/tools/</link><description>Recent content in Tools on crazyc4t's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 06 Dec 2022 14:34:23 -0500</lastBuildDate><atom:link href="https://crazyc4t.xyz/categories/tools/index.xml" rel="self" type="application/rss+xml"/><item><title>Elk stack once and for all!</title><link>https://crazyc4t.xyz/blog/elk-stack/</link><pubDate>Tue, 06 Dec 2022 14:34:23 -0500</pubDate><guid>https://crazyc4t.xyz/blog/elk-stack/</guid><description>&lt;img src="https://crazyc4t.xyz/images/elkbanner.png" alt="Featured image of post Elk stack once and for all!" />&lt;p>Welcome to this quick guide on using the ELK stack, specially Elastic&amp;rsquo;s Kibana interface to search, filter and create visualizations and dashboards, taking as an example the investigation of vpn logs for anomalies.&lt;/p>
&lt;p>&lt;img src="https://crazyc4t.xyz/images/elk1.png"
loading="lazy"
alt="elk1"
>&lt;/p>
&lt;p>Is a collection of different open-source software developed by Elastic, linked together to take data from endpoints (computers, networks, any source in particular) in any format and being able to perform a search, analyze and visualize the data in real-time.&lt;/p>
&lt;p>One works with the other, it&amp;rsquo;s like you have a VR headset without a VR video to watch, or you have a VR video without any VR headset to visualize with, let&amp;rsquo;s look it more in-depth:&lt;/p>
&lt;h2 id="elasticsearch">ElasticSearch&lt;/h2>
&lt;p>Is a full-text search and analytics engine used to store JSON documents, being a critical part since is the component used to store, analyze, perform correlation on the data and so much more, having a RESTfull API to interact with it.&lt;/p>
&lt;h2 id="logstash">Logstash&lt;/h2>
&lt;p>Data processing engine used to take the data the data from different sources, apply a filter or normalize it, and then send it to the destination, being the majority of the cases a elasticsearch database, kibana or a listening port, being separated like this:&lt;/p>
&lt;p>&lt;img src="https://crazyc4t.xyz/images/elk2.png"
loading="lazy"
alt="elk2"
>&lt;/p>
&lt;h3 id="input">Input&lt;/h3>
&lt;p>User defines the source where the data is ingested, while it has a lot of input plugins like azure events, is better to use beats to follow the stack.&lt;/p>
&lt;h3 id="filter">Filter&lt;/h3>
&lt;p>Where the user defines the filter options to normalize the data, for example: age, bytes, clones and more.&lt;/p>
&lt;h3 id="output">Output&lt;/h3>
&lt;p>This is the part where the filtered data is sended to a listening port, elasticsearch database, or kibana.&lt;/p>
&lt;h2 id="beats">Beats&lt;/h2>
&lt;p>Host-based agent (Meaning that is a program that you install or set up for each of your devices) known as data-shippers since it&amp;rsquo;s used to send data from the endpoints to logstash, or elasticsearch, for example all the &amp;ldquo;beats&amp;rdquo; available:&lt;/p>
&lt;p>&lt;img src="https://crazyc4t.xyz/images/elk3.png"
loading="lazy"
alt="elk3"
>&lt;/p>
&lt;h2 id="kibana">Kibana&lt;/h2>
&lt;p>Is a web-based data visualization that works with elasticsearch to analyze, investigate and visualize the data stream in real-time, you can create multiple visualizations, dashboards and specific lookups with KQL (Kibana query language) more on that later.&lt;/p>
&lt;h2 id="how-they-work-together">How they work together&lt;/h2>
&lt;p>&lt;img src="https://crazyc4t.xyz/images/elk4.png"
loading="lazy"
alt="elk4"
>&lt;/p>
&lt;h1 id="getting-our-feets-wet-with-kibana">Getting our feets wet with Kibana&lt;/h1>
&lt;p>This is the discover tab in our Kibana instance, if you have used Splunk before, they are fundamentally the same, and that&amp;rsquo;s why it&amp;rsquo;s going to be easy to get started with, since they are both SIEMs.&lt;/p>
&lt;p>&lt;img src="https://crazyc4t.xyz/images/elk5.png"
loading="lazy"
alt="elk5"
>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Logs (document):&lt;/strong> Each log here is also known as a single document containing information about the event. It shows the fields and values found in that document.&lt;/li>
&lt;li>&lt;strong>Fields pane&lt;/strong>: Left panel of the interface shows the list of the fields parsed from the logs. We can click on any field to add the field to the filter or remove it from the search.&lt;/li>
&lt;li>&lt;strong>Index Pattern:&lt;/strong> Let the user select the index pattern from the available list.&lt;/li>
&lt;li>&lt;strong>Search bar:&lt;/strong> A place where the user adds search queries / applies filters to narrow down the results.&lt;/li>
&lt;li>&lt;strong>Time Filter:&lt;/strong> We can narrow down results based on the time duration. This tab has many options to select from to filter/limit the logs.&lt;/li>
&lt;li>&lt;strong>Time Interval:&lt;/strong> This chart shows the event counts over time.&lt;/li>
&lt;li>&lt;strong>Inspector:&lt;/strong> This tab helps us understand the request Kibana is doing to elasticsearch, by seeing the json structure.&lt;/li>
&lt;li>&lt;strong>Application:&lt;/strong> Is the name of the application we are using, in this case Discover, we can save our session to return to it later or manage the saved sessions.&lt;/li>
&lt;li>&lt;strong>Add filter:&lt;/strong> Self-explanatory, it helps us add specific filters with logical operators.&lt;/li>
&lt;/ol>
&lt;p>Our best friend here is the fields pane since it gives us a brief overlook about all the information and helps us to filter them fast.&lt;/p>
&lt;h2 id="kql">KQL&lt;/h2>
&lt;p>The Kibana Query Language is a search query language used to search the ingested logs in the elasticsearch, it does not have tons of features but it is really easy to pick up, another option is the Lucene Query Language (LQL) so is opt to the user.&lt;/p>
&lt;h3 id="free-text-search">Free text search&lt;/h3>
&lt;p>Here you can put any text into the box and it will search it irrespective of the field, for example:&lt;/p>
&lt;p>&lt;img src="https://crazyc4t.xyz/images/elk6.png"
loading="lazy"
alt="elk6"
>&lt;/p>
&lt;p>But what happens if we only search for &amp;ldquo;United&amp;rdquo;?
&lt;img src="https://crazyc4t.xyz/images/elk7.png"
loading="lazy"
alt="elk7"
>
It will not return any result because KQL looks only for the whole term, here is where wildcards come into play.&lt;/p>
&lt;h3 id="wildcards">Wildcards&lt;/h3>
&lt;p>Let&amp;rsquo;s use them! But before that let&amp;rsquo;s do a quick rundown on wildcards:&lt;/p>
&lt;ul>
&lt;li>&lt;code>*&lt;/code>: To match any characters and there is &lt;strong>no limit to their number&lt;/strong>&lt;/li>
&lt;li>&lt;code>?&lt;/code>: To match any &lt;strong>single&lt;/strong> character&lt;/li>
&lt;li>&lt;code>[characters]&lt;/code>: To match any character &lt;strong>inside&lt;/strong> the &lt;code>[]&lt;/code>&lt;/li>
&lt;li>&lt;code>[!characters]&lt;/code>: To match any character that is &lt;strong>not inside&lt;/strong> the &lt;code>[]&lt;/code>&lt;/li>
&lt;li>&lt;code>{}&lt;/code>: To match a group of names/wildcards patterns&lt;/li>
&lt;/ul>
&lt;p>Now knowing wildcards, let&amp;rsquo;s search United* and see the results:&lt;/p>
&lt;p>&lt;img src="https://crazyc4t.xyz/images/elk8.png"
loading="lazy"
alt="elk8"
>&lt;/p>
&lt;h3 id="logical-operators">Logical Operators&lt;/h3>
&lt;p>KQL supports logical operators (AND | OR | NOT), quick examples:&lt;/p>
&lt;h4 id="or">OR&lt;/h4>
&lt;p>Search: &lt;code>&amp;quot;United States&amp;quot; OR &amp;quot;England&amp;quot;&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://crazyc4t.xyz/images/elk9.png"
loading="lazy"
alt="elk9"
>&lt;/p>
&lt;h4 id="and">AND&lt;/h4>
&lt;p>Search: &lt;code>&amp;quot;United States&amp;quot; AND &amp;quot;Virgina&amp;quot;&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://crazyc4t.xyz/images/elk10.png"
loading="lazy"
alt="elk10"
>&lt;/p>
&lt;h4 id="not">NOT&lt;/h4>
&lt;p>Search: &lt;code>&amp;quot;United States&amp;quot; AND NOT (&amp;quot;Florida&amp;quot;)&lt;/code>, Saying all the results that match United States without florida.&lt;/p>
&lt;p>&lt;img src="https://crazyc4t.xyz/images/elk11.png"
loading="lazy"
alt="elk11"
>&lt;/p>
&lt;h3 id="field-based-search">Field-based search&lt;/h3>
&lt;p>Here you can search for a specific value in a field, using the semicolon &amp;ldquo;:&amp;rdquo; being &lt;code>field:value&lt;/code>.&lt;/p>
&lt;p>Look at this example:&lt;/p>
&lt;p>&lt;img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/ffbf735277d98273d6229f4d9ee586bf.gif"
loading="lazy"
alt="Kibana gif"
>&lt;/p>
&lt;p>Kibana automatically will show you available fields and values, making your search easier.&lt;/p>
&lt;h3 id="visualize">Visualize&lt;/h3>
&lt;p>Visualizing is using an built-into kibna elastic application called lens that helps us read with statistics, for example in this image we can view all the connections made to a VPN.&lt;/p>
&lt;p>&lt;img src="https://crazyc4t.xyz/images/elk12.png"
loading="lazy"
alt="elk12"
>&lt;/p>
&lt;p>We can visualize by clicking the wanted field in the fields pane and clicking on visualize:&lt;/p>
&lt;p>&lt;img src="https://crazyc4t.xyz/images/elk13.png"
loading="lazy"
alt="elk13"
>&lt;/p>
&lt;p>We can edit the rules as we want, by clicking the field, in this example the rows top values of usernames:&lt;/p>
&lt;p>&lt;img src="https://crazyc4t.xyz/images/elk14.png"
loading="lazy"
alt="elk14"
>&lt;/p>
&lt;p>There are endless possibilites, you can save them as well and add it to your dashboard.&lt;/p>
&lt;p>&lt;img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/334ed7c0a1e727de35844174434fd4fc.gif"
loading="lazy"
alt="Visualization Gif"
>&lt;/p>
&lt;p>Like so:&lt;/p>
&lt;p>&lt;img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/05016a6cc1c12d40b90ce9d290525378.gif"
loading="lazy"
alt="add dashboard"
>&lt;/p>
&lt;h1 id="where-to-go-from-here">Where to go from here?&lt;/h1>
&lt;ol>
&lt;li>Put your knowledge to the test with the ItsyBitsy machine, where you will need to investigate an alert by IDS regarding a potential C2 communication, here is the &lt;a class="link" href="https://tryhackme.com/room/itsybitsy" target="_blank" rel="noopener"
>link&lt;/a>&lt;/li>
&lt;li>Set up your own kibana instance with sample data! You can do so with a virtual machine (Ubuntu 22.10 or Debian 11 is perfect) and start playing around!&lt;/li>
&lt;li>Read the &lt;a class="link" href="https://www.elastic.co/guide/en/kibana/current/get-started.html" target="_blank" rel="noopener"
>docs&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Deep dive into nmap</title><link>https://crazyc4t.xyz/blog/nmap/</link><pubDate>Sat, 05 Nov 2022 13:17:13 -0500</pubDate><guid>https://crazyc4t.xyz/blog/nmap/</guid><description>&lt;img src="https://crazyc4t.xyz/images/nmaplogo.jpg" alt="Featured image of post Deep dive into nmap" />&lt;p>When it comes to hacking, knowledge is power, the more you know, the more options you have to attack, making critical a proper enumeration before any type of exploitation.&lt;/p>
&lt;p>Before attacking our target we need to know what is what we are about to attack, we need to know what type of services or OS is running, and we can accomplish that by making a network map, hence the name of Nmap, specifically doing &amp;ldquo;port scanning&amp;rdquo;, because these services are listening on a specific &amp;ldquo;ports&amp;rdquo; of the network, being ports a network structure your service runs on to establish a connection, the service are always &amp;ldquo;listening&amp;rdquo; (waiting for another device that wants to establish a connection) and the user when connecting to the specific port they open a port for receiving information from the other port (for example: HTTPS 443)&lt;/p>
&lt;p>&lt;img src="https://crazyc4t.xyz/images/nmap.png"
loading="lazy"
alt="image"
>&lt;/p>
&lt;p>All of this reconnaissance we can achieve using nmap, so keep reading!&lt;/p>
&lt;h2 id="nmap-arguments">Nmap Arguments&lt;/h2>
&lt;p>Let&amp;rsquo;s get our hands dirty, open the terminal and install nmap (comes installed by default in kali linux and parrot os) and run:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">nmap -h
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>To know which arguments can be used in nmap, listing some basic and really useful arguments:&lt;/p>
&lt;ul>
&lt;li>&lt;code>-sS&lt;/code>: Syn Scan&lt;/li>
&lt;li>&lt;code>-sU&lt;/code>: UPD Scan&lt;/li>
&lt;li>&lt;code>-O&lt;/code>: OS detection&lt;/li>
&lt;li>&lt;code>-sV&lt;/code>: Version of the service running on ports&lt;/li>
&lt;li>&lt;code>-vvv&lt;/code>: Verbosity 3x&lt;/li>
&lt;li>&lt;code>-oA, -oN, -oS, -oG&lt;/code>: Gives the output on different formats (all, normal, script kiddie, grepable)&lt;/li>
&lt;li>&lt;code>-A&lt;/code>: Aggresive (I don&amp;rsquo;t care if they know someone is scanning them, give me all the info!)&lt;/li>
&lt;li>&lt;code>-T5&lt;/code>: Go fast g&lt;/li>
&lt;li>&lt;code>-p xx&lt;/code>: Only scan xx port&lt;/li>
&lt;li>&lt;code>-p-&lt;/code>: Scan all ports&lt;/li>
&lt;/ul>
&lt;h2 id="types-of-scans">Types of Scans&lt;/h2>
&lt;p>We are going to look more in-depth of the types of scanning that are available like:&lt;/p>
&lt;ul>
&lt;li>TCP connect scans (&lt;code>-sT&lt;/code>)&lt;/li>
&lt;li>SYN &amp;ldquo;half-open&amp;rdquo; scans (&lt;code>-sS&lt;/code>)&lt;/li>
&lt;li>UDP Scans (&lt;code>-sU&lt;/code>)&lt;/li>
&lt;/ul>
&lt;h2 id="tcp-connect-scans">TCP Connect Scans&lt;/h2>
&lt;p>This type of scans are made when completing the three-way handshake:&lt;/p>
&lt;p>&lt;img src="https://crazyc4t.xyz/images/nmap1.png"
loading="lazy"
alt="image1"
>&lt;/p>
&lt;p>Where it sends a SYN packet to the specified port, if it receives the SYN/ACK, it will reply with ACK, and terminating the handshake, having closed the connection, it will know that the port is open.&lt;/p>
&lt;p>&lt;strong>What happens if it&amp;rsquo;s closed?&lt;/strong>
When sending a SYN packet, the target replies with RST (reset), that means the port is closed (does not exist)&lt;/p>
&lt;p>&lt;img src="https://crazyc4t.xyz/images/nmap2.png"
loading="lazy"
alt="image2"
>&lt;/p>
&lt;p>&lt;strong>If it&amp;rsquo;s behind a firewall?&lt;/strong>
It will just drop the connection, it won&amp;rsquo;t reply back at all, and when this happens, nmap declares these types of ports being &lt;strong>filtered&lt;/strong>&lt;/p>
&lt;p>Example:
&lt;code>nmap -sT &amp;lt;ip&amp;gt;&lt;/code>&lt;/p>
&lt;h2 id="syn-scans">SYN Scans&lt;/h2>
&lt;p>These are similar to the TCP scans, but are referred as &amp;ldquo;half-open&amp;rdquo; or &amp;ldquo;stealth&amp;rdquo;, because when receiving the SYN/ACK packet, it will send instead of ACK, RST, closing the connection early and therefore no letting the target re-send packets again, being faster and stealthier because the majority of the times only full TCP connections are logged, and this is not one of those.&lt;/p>
&lt;p>Example:
&lt;code>nmap -sS &amp;lt;ip&amp;gt;&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://crazyc4t.xyz/images/nmap3.png"
loading="lazy"
alt="nmap3"
>&lt;/p>
&lt;h2 id="udp-scans">UDP Scans&lt;/h2>
&lt;p>UDP is stateless, being that it does not require a established connection to transmit packets, so nmap just send packets to the target, and if the target does not reply back it the port is flagged as &lt;strong>open|filtered&lt;/strong> because does not reply it could be filtered because of a firewall between it, and nmap knows that is closed when it sends a ICMP packet back with a message that the port is unreachable, knowing exactly that the port is closed.&lt;/p>
&lt;p>Because of the lack of acknowledgement of UDP, UDP scans are terrible slow, so you should only scan the top 20 UDP ports, for example: &lt;code>nmap -sU --top-ports 20 &amp;lt;ip&amp;gt;&lt;/code>&lt;/p>
&lt;h2 id="null-fin-and-xmas">NULL, FIN and Xmas&lt;/h2>
&lt;p>This are stealthier types of scan, so let&amp;rsquo;s briefly go through them:&lt;/p>
&lt;h3 id="null">NULL&lt;/h3>
&lt;p>This is when instead of sending a SYN packet, it sends a NULL packet, being essentially none, nothing, and the reply back is a RST/ACK.&lt;/p>
&lt;p>Example: &lt;code>nmap -sN &amp;lt;ip&amp;gt;&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://crazyc4t.xyz/images/nmap4.png"
loading="lazy"
alt="nmap4"
>&lt;/p>
&lt;h3 id="fin">FIN&lt;/h3>
&lt;p>It is the same as NULL, but instead is a FIN packet (final), that is used to end the connection, so the reply is the same as NULL.&lt;/p>
&lt;p>Example: &lt;code>nmap -sF &amp;lt;ip&amp;gt;&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://crazyc4t.xyz/images/nmap5.png"
loading="lazy"
alt="nmap5"
>&lt;/p>
&lt;h2 id="xmas">Xmas&lt;/h2>
&lt;p>Xmas scans send a malformed TCP packet and expects a RST reply for closed ports.
&lt;img src="https://crazyc4t.xyz/images/nmap6.png"
loading="lazy"
alt="nmap6"
>&lt;/p>
&lt;p>But all of these scans does not expect a reply for knowning open ports, like UDP scans, so they will acknowledge ports closed or open|filtered, but only filtered as well when receiving an ICMP unreachable packet.&lt;/p>
&lt;p>The goal here is to bypass firewalls, this is not 100% effective since most modern IDS (Intrusion Detection System) are smart about this.&lt;/p>
&lt;p>It is common that MS Windows reply to every NULL, FIN, XMAS scan with a RST.&lt;/p>
&lt;p>Example: &lt;code>nmap -sX &amp;lt;ip&amp;gt;&lt;/code>&lt;/p>
&lt;h2 id="icmp-network-scanning">ICMP Network Scanning&lt;/h2>
&lt;p>This comes in place in a &amp;ldquo;black box&amp;rdquo; scenario, where we don&amp;rsquo;t know nothing, so our first step is to create a map of active hosts, we can accomplish doing this with a &amp;ldquo;ping sweep&amp;rdquo; where we send a ICMP packet to every host in the subnet of the IP given, and expect they will receive it to know they are active.&lt;/p>
&lt;p>Example: &lt;code>nmap -sn 192.168.0.0/24&lt;/code>&lt;/p>
&lt;p>This does not scan ports, however it will send a TCP SYN packet to ports 443 and 80.&lt;/p>
&lt;h2 id="nse-overview">NSE Overview&lt;/h2>
&lt;p>The Nmap Scritpting Engine is a powerful addition to nmap, being written in lua is really easy to do tons of things, like scanning for vulnerabilities, even to exploiting, these are the most popular and useful categories:&lt;/p>
&lt;ul>
&lt;li>&lt;code>safe&lt;/code>: Won&amp;rsquo;t affect the target&lt;/li>
&lt;li>&lt;code>intrusive&lt;/code>: Not safe: likely to affect the target&lt;/li>
&lt;li>&lt;code>vuln&lt;/code>: Scan for vulnerabilities&lt;/li>
&lt;li>&lt;code>exploit&lt;/code>: Attempt to exploit a vulnerability&lt;/li>
&lt;li>&lt;code>auth&lt;/code>: Attempt to bypass authentication for running services (e.g. Log into an FTP server anonymously)&lt;/li>
&lt;li>&lt;code>brute&lt;/code>: Attempt to bruteforce credentials for running services&lt;/li>
&lt;li>&lt;code>discovery&lt;/code>: Attempt to query running services for further information about the network (e.g. query an SNMP server).&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://nmap.org/nsedoc/" target="_blank" rel="noopener"
>Learn more about NSE here&lt;/a>&lt;/p>
&lt;p>All the NSE scripts are located on &lt;code>/usr/share/nmap/scripts/&lt;/code>&lt;/p>
&lt;h2 id="outro">Outro&lt;/h2>
&lt;p>Special thanks to the &lt;a class="link" href="https://tryhackme.com/room/furthernmap" target="_blank" rel="noopener"
>Try Hack Me nmap room&lt;/a> since thanks to that room I learned more in-depth about nmap.&lt;/p>
&lt;p>Thanks for reading! I will upload more blogposts specified on certain pentesting tools like this one!&lt;/p></description></item></channel></rss>